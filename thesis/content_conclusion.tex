% Conclusion %
\chapter{Conclusion}
\label{chapter6}
In this thesis, an application was presented that enables \roismall in single-threaded \CPP programs to be automatically wrapped with performance counters to find performance bottlenecks in the source code. This was achieved by first developing a concept for traversing the \CLANG \astsmall and categorizing individual nodes. Afterwards, the functionality of the program was determined and a recursive model for the hierarchical traversal of the levels was found. Having worked out all the basic concepts, we took advantage of the \CLANG infrastructure by using the \LIBTOOLING library to develop a \CLANG tool that fulfilled our requirements. When developing this tool, we looked at how the concepts could be used to insert performance counters in the correct places in the source code. The developed program could then be used to test four applications of different complexities and runtimes for performance bottlenecks. This showed the workflow of the profiling process with this tool and proved that a resource-heavy instruction could be found in each program. Furthermore, we were able to perform a detailed overhead analysis by running each variation of the applications a number of times. In the process, we found out how much time is added by a counter and which parameters have to be taken into account when using the tool. 

\subsection{Limitations}
The implementation of the tool at this stage is limited by several constraints that were not addressed in the research question. First, it must be mentioned that the tool was developed to profile \CPP applications, but not \C or \OC. \CLANG also offers infrastructures for traversing other languages from the \C programming language family and thus the tool could be adapted based on the concepts created. To include other members of the \C language family, for instance, an additional parameter could be created for the tool, with which the user can specify which programming language is to be transformed. The file extension could also be used to determine which programming language is involved. Depending upon the language in which the input program is written, further case distinctions could be added subsequently, which address concrete characteristics of the different languages. As an example the \lstinline{CXXMemberCallExpr} can be considered. This class exists in the object-oriented language \CPP, but it is not found in an \astsmall of the \C language, which means that a case distinction would be necessary.

Another limitation we have decided in the course of the work is that not all classes that are defined in the \CLANG \astsmall are recognized separately by our tool. In this work, we have chosen a number of classes with which a variety of applications can be transformed. Further classes can be added however as desired to the present implementation. To achieve this it is necessary to consider other classes of the \astsmall provided by \CLANG and determine whether they are \LEASTAS or \PARSTAS. The existing case distinctions in the current implementation can easily be extended with new class queries. 

It should also be noted that the tool has only been applied and tested on single-threaded applications. The concepts developed can also be used for multi-threaded applications, but further special cases must be considered in more detail. Due to the concurrent processing of the instructions, it must be ensured that the data structure that manages the runtimes is synchronized, or that there is a separate storage for each thread, which is reassembled at the end of the application. 

Finally, it should be mentioned that the overhead analysis that is passed on to the user in addition to the statistics was not part of the research objective. Nevertheless, we succeeded in correctly allocating about half of the overhead without the implementation of additional calculations or predictions about the running times of the counters added. In order for the tool to be able to filter out the generated overhead even better, an algorithm could be designed, for instance, that determines how much overhead is generated in total based on the already correctly assigned share of overhead and on historical data. Thus, it would be possible to determine even more precisely how much runtime each code block really consumed. 